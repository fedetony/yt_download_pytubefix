# -*- coding: utf-8 -*-
"""
# *********************************
# Author :F. Garcia
# Created 04.08.2024
# *********************************
"""
__author__ = "FG"
__version__ = "1.0.0 Beta"
__creationdate__ = "04.08.2024"
__gitaccount__ = "<a href=\"https://github.com/fedetony\">' Github for fedetony'</a>"
__pytubefix__ = "<a href=\"https://github.com/JuanBindez/pytubefix\">' Github for pytubefix'</a>"

# Form implementation generated automaticaly from reading ui file 'yt_pytubefix_gui.ui'
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to 'yt_pytubefix_gui.py' will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys
import os
import logging
import threading
import time
import json
import datetime
import subprocess

from importlib.metadata import version
import yaml
import requests
from PyQt5 import QtCore, QtGui, QtWidgets

import pytubefix
import pytubefix.metadata

# from genericpath import isfile
# from operator import index

import class_file_dialogs
import class_table_widget_functions
import class_pytubefix_use
import class_signal_tracker
import class_useful_functions
import class_log_dialog
import thread_download_pytubefix
import yt_pytubefix_gui

# import yt_pytubefix_log_dialog

# import json
# import re
# Setup Logger
# set up logging to file - see previous section for more details
log = logging.getLogger("")  # root logger
# For file
APP_PATH = ""
if getattr(sys, "frozen", False):
    APP_PATH = os.path.dirname(sys.executable)
elif __file__:
    APP_PATH = os.path.dirname(__file__)
LOG_PATH = APP_PATH + os.sep + "logs"
if not os.path.exists(LOG_PATH):
    os.mkdir(LOG_PATH)

logging.basicConfig(
    level=logging.DEBUG, format="%(asctime)s [%(levelname)s] (%(threadName)-10s) %(message)s", datefmt="%y-%m-%d %H:%M"
)
# define a Handler which writes INFO messages or higher to the sys.stderr
# console = logging.StreamHandler()
console = logging.StreamHandler(sys.stdout)
console.setLevel(logging.DEBUG)
# set a format which is simpler for console use
formatter = logging.Formatter("[%(levelname)s] (%(threadName)-10s) %(message)s")
file_formatter = logging.Formatter("%(asctime)s [%(levelname)s] (%(threadName)-10s) %(message)s")
# tell the handler to use this format
console.setFormatter(formatter)

file_handler = logging.FileHandler(LOG_PATH + os.sep + "__yt_pytubefix_gui__.log")
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(file_formatter)
# add the handlers to the root logger
logging.getLogger("").addHandler(console)
logging.getLogger("").addHandler(file_handler)
logging.getLogger("").propagate = False


class UiMainWindowYt(yt_pytubefix_gui.Ui_MainWindow):
    """GUI for handleing Pytubefix

    Args:
        yt_pytubefix_gui (_type_): Gui build automatically by useing Designer and
        python -m PyQt5.uic.pyuic -x yt_pytubefix_gui.ui  -o yt_pytubefix_gui.py
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.a_dialog = class_file_dialogs.Dialogs()
        self.a_ufun = class_useful_functions.UsefulFunctions()
        self.app_path = ""
        self.general_config = {}
        self.download_path = ""
        self.url_struct = {}
        self.url_struct_results = {}
        self.url_id_counter = 0
        self.ongoing_download_url = None
        self.ongoing_download_title = None
        self.url_struct_mask = {}
        self.url_struct_results_mask = {}
        self.url_struct_options = {}
        # icons
        self.icon_main_pixmap = QtGui.QIcon()
        self.icon_main_pixmap = QtGui.QIcon()
        self.icon_main = QtGui.QIcon()
        self.icon_main = QtGui.QIcon()
        self.icon_plus = QtGui.QIcon()
        self.icon_log = QtGui.QIcon()
        self.icon_explorer = QtGui.QIcon()
        self.icon_open_file = QtGui.QIcon()
        self.icon_save_file = QtGui.QIcon()
        self.icon_info = QtGui.QIcon()
        self.icon_toggle = QtGui.QIcon()
        self.icon_play = QtGui.QIcon()
        self.icon_bin = QtGui.QIcon()
        self.icon_download_all = QtGui.QIcon()
        self.icon_download_selected = QtGui.QIcon()
        self.icon_download_folder = QtGui.QIcon()
        self.icon_clear = QtGui.QIcon()
        self.icon_minus = QtGui.QIcon()

        self.twf = None
        self.twf2 = None
        self.ptf = None
        self.st = None
        self.default_config_path = None
        self.path_config_file = None
        self.item_menu = None
        self.threads_event_list = []
        self.threads_mapping_dict = {}
        self.log_dia = None
        self.log_text_box = None

    def start_up(self):
        """Start the UI first to get all objects in"""
        log.info("UI started!")
        # Initial conditions variables
        self.app_path = self.a_dialog.get_app_path()
        self.general_config = self.get_general_config()
        try:
            self.download_path = ""
            if isinstance(self.general_config["Last_Path_for_Download"],list):
                self.download_path = self.general_config["Last_Path_for_Download"][0]
            if isinstance(self.general_config["Last_Path_for_Download"],str):
                self.download_path = self.general_config["Last_Path_for_Download"]
            if not os.path.exists(self.download_path):
                self.download_path = self.app_path
        except (TypeError, KeyError, IndexError):
            self.download_path = self.app_path
        self.url_struct = {}
        self.url_struct_mask = {
            "__any__": {
                "Index": {"__m__1": "is_unique", "__mv__1": ""},
                "DL Status": {"__m__1": "is_not_change", "__mv__1": ""},
                # "Resolution": {"__m__1": "is_not_change", "__mv__1": ""}, # dont mask if it has widget
                "Title": {"__m__1": "is_value_type", "__mv__1": str(str)},
                "URL": {"__m__1": "is_value_type", "__mv__1": str(str), "__m__2": "is_not_change", "__mv__2": ""},
                "DL Enable": {"__m__1": "is_value_type", "__mv__1": str(bool)},
                "MP3": {"__m__1": "is_value_type", "__mv__1": str(bool)},
                "Skip Existing": {"__m__1": "is_value_type", "__mv__1": str(bool)},
                "Timeout sec": {
                    "__m__1": "is_value_type",
                    "__mv__1": str(int),
                    "__m__2": "is_value_gteq",
                    "__mv__2": 0,
                },
                "Max Retries": {
                    "__m__1": "is_value_type",
                    "__mv__1": str(int),
                    "__m__2": "is_value_gteq",
                    "__mv__2": 0,
                    "__m__3": "is_value_lteq",
                    "__mv__3": 10,
                },
                "File Name": {"__m__1": "is_format", "__mv__1": r"^[a-zA-Z0-9._-]+(\.[a-zA-Z0-9._-]+)?$"},
                "File Name Prefix": {"__m__1": "is_format", "__mv__1": r"^[a-zA-Z0-9._-]+$"},
                "Download Path": {"__m__1": "is_not_change", "__mv__1": ""},
                # "Selected Resolution Codec": {"__m__1": "is_value_type", "__mv__1": str(str)},
            },
            # This was to test restriction on a specific id :) works
            # "URL0": {
            #     "Title": {'__m__1':"is_value_type",'__mv__1':str(str),
            #             '__m__2':"is_not_change",'__mv__2':""},
            # },
        }

        self.url_id_counter = 0
        self.ongoing_download_url = None
        self.ongoing_download_title = None

    def setup_ui2(self, amain_window: QtWidgets.QMainWindow):
        """Start main

        Args:
            amain_window (QtWidgets.QMainWindow): Mainwindow Object From Mywindow Class
            Modifies the closing event.
        """
        # Add objects by code here additional to objects in GUI_PostProcessing
        # Or set configuration of objects
        # initial conditions
        self.start_up()
        # ------------- Mainwindow
        # set the icons
        self._set_icons()
        if self.icon_main:
            amain_window.setWindowIcon(self.icon_main)

        # set the title
        amain_window.setWindowTitle("Gui for pytubefix by " + __author__ + " V" + __version__)
        # amain_window.showMaximized()

        # -----------TableWidgetFunctions

        self.twf = class_table_widget_functions.TableWidgetFunctions(
            self.tableWidget_url, self.url_struct, self.url_struct_mask, None, []
        )
        # self.model=self.twf.modelobj
        self.twf.signal_data_change[list, str, str, str].connect(self._table_widget_data_changed)
        self.twf.signal_item_button_right_clicked[list, QtCore.QPoint].connect(self._table_item_right_clicked)
        self.twf.signal_item_combobox_currentindexchanged[int, str, list].connect(self._table_item_comboboxindexchanged)

        self.twf2 = class_table_widget_functions.TableWidgetFunctions(
            self.tableWidget_results, self.url_struct_results, self.url_struct_results_mask, None, []
        )
        # self.model=self.twf.modelobj
        # self.twf2.signal_data_change[list, str, str, str].connect(self._table_widget_data_changed)
        self.twf2.signal_item_button_right_clicked[list, QtCore.QPoint].connect(self._table_results_item_right_clicked)

        # --------------use_pytubefix
        self.ptf = class_pytubefix_use.use_pytubefix()

        # -----------Splitter
        # self._set_splitter_pos(400,1/3) #initial position
        # --------------
        self._set_path_labels()
        self.a_dialog.set_default_dir(self.app_path)
        self._connect_actions()

    def _set_icon_to_object(self, path_to_file, icon_obj: QtGui.QIcon, obj_set_icon):
        """_summary_

        Args:
            path_to_file (_type_): path where image is, None for setting icon to object only
            icon_obj (QtGui.QIcon): icon object
            obj_set_icon (QObject): object to assign icon
        """
        if os.path.exists(path_to_file):
            icon_obj = QtGui.QIcon(QtGui.QPixmap(path_to_file))
            if obj_set_icon:
                obj_set_icon.setIcon(icon_obj)
        elif not path_to_file and obj_set_icon:
            obj_set_icon.setIcon(icon_obj)
        return icon_obj

    def _set_icons(self):
        """Sets the icons if they are found"""
        image_path = self.app_path + os.sep + "img" + os.sep
        path_to_file = image_path + "main_icon.png"
        if os.path.exists(path_to_file):
            self.icon_main_pixmap = QtGui.QPixmap(path_to_file)
            self.icon_main = QtGui.QIcon(QtGui.QPixmap(path_to_file))

        path_to_file = image_path + "document_icon.png"
        self.icon_log = self._set_icon_to_object(path_to_file, self.icon_log, self.actionShow_Log)

        path_to_file = image_path + "plus_icon.png"
        self.icon_plus = self._set_icon_to_object(path_to_file, self.icon_plus, self.pushButton_url)

        path_to_file = image_path + "explorer_file_icon.png"
        self.icon_explorer = self._set_icon_to_object(path_to_file, self.icon_explorer, self.pushButton_2)

        path_to_file = image_path + "open_file_icon.png"
        self.icon_open_file = self._set_icon_to_object(path_to_file, self.icon_open_file, self.actionOpen_URL_list)

        path_to_file = image_path + "save_file_icon.png"
        self.icon_save_file = self._set_icon_to_object(path_to_file, self.icon_save_file, self.actionSave_URL_list)

        path_to_file = image_path + "info_icon.png"
        self.icon_info = self._set_icon_to_object(path_to_file, self.icon_info, self.actionAbout)

        path_to_file = image_path + "download_folder_icon.png"
        self.icon_download_folder = self._set_icon_to_object(
            path_to_file, self.icon_download_folder, self.actionSet_Path
        )

        path_to_file = image_path + "minus_icon.png"
        self.icon_minus = self._set_icon_to_object(path_to_file, self.icon_minus, None)

        path_to_file = image_path + "download_all_icon.png"
        self.icon_download_all = self._set_icon_to_object(path_to_file, self.icon_download_all, self.pushButton_4)

        path_to_file = image_path + "download_selected_icon.png"
        self.icon_download_selected = self._set_icon_to_object(path_to_file, self.icon_download_selected, None)

        path_to_file = image_path + "clear_icon.png"
        self.icon_clear = self._set_icon_to_object(path_to_file, self.icon_clear, self.pushButton_5)

        path_to_file = image_path + "toggle_icon.png"
        self.icon_toggle = self._set_icon_to_object(path_to_file, self.icon_toggle, self.pushButton_3)

        path_to_file = image_path + "button_play_icon.png"
        self.icon_play = self._set_icon_to_object(path_to_file, self.icon_play, None)

        path_to_file = image_path + "bin_icon.png"
        self.icon_bin = self._set_icon_to_object(path_to_file, self.icon_bin, None)

    def _table_widget_data_changed(self, track: list[str], val: any, valtype: str, subtype: str):
        """Sets the changed information in table widget by user into the Structure

        Args:
            track (list[str]): _description_
            val (any): _description_
            valtype (str): _description_
            subtype (str): _description_
        """
        # print("before: %s",self.url_struct)
        processed_val = self.twf.check_restrictions.set_type_to_value(val, valtype, subtype)
        self.twf.set_tracked_value_to_dict(track, processed_val, self.url_struct, subtype, False)
        self._update_shared_struct_options()
        # update shared values

    def _update_shared_struct_options(self):
        """Updates the info shared in both dictionaries"""

        for key_s in self.url_struct:
            struct_dict = self.url_struct[key_s]
            self.url_struct_options.update(
                {
                    key_s: {
                        "URL": struct_dict["URL"],
                        "output_path": (
                            self.download_path if struct_dict["Download Path"] == "" else struct_dict["Download Path"]
                        ),
                        "filename": None if struct_dict["File Name"] == "" else struct_dict["File Name"],
                        "filename_prefix": (
                            None if struct_dict["File Name Prefix"] == "" else struct_dict["File Name Prefix"]
                        ),
                        "skip_existing": struct_dict["Skip Existing"],
                        "timeout": None if int(struct_dict["Timeout sec"]) <= 0 else int(struct_dict["Timeout sec"]),
                        "max_retries": int(struct_dict["Max Retries"]),
                        "mp3": struct_dict["MP3"],
                        "selected_resolution": "",
                    },
                }
            )
            self.url_struct_options[key_s].update({"mp3": self.url_struct[key_s]["MP3"]})
            self.url_struct_options[key_s].update({"selected_resolution": self.url_struct[key_s]["Resolution"]})

    def _pytubefix_download_progress(self, url: str, per: float):
        """Shows download progress"""
        url_id = self._identify_urlid_from_url_str(url)

        # printing too many lines when joining video and audio
        # txt = f"Downloaded {per}% for {url_id} {url}"
        # log.info(txt)

        # add widget to twf
        it_w_dict = self.twf.itemwidget_dict.copy()
        track_list = it_w_dict["track_list"]
        widget_list = it_w_dict["widget_list"]
        # get widget object
        for track, progress_bar in zip(track_list, widget_list):
            if self._is_same_list(track, [url_id, "DL Status"]):
                if isinstance(progress_bar, QtWidgets.QProgressBar):
                    progress_bar.setProperty("value", per)

    def _pytubefix_download_start(self, url: str, title: str):
        """Receives Signal form Pytube fix when a Download is started

        Args:
            url (str): url of download
            title (str): title of the download
        """
        # print("========== >>>>>> Main got Signal Start <<<<<<< ==========  \n" * 5)

        self.ongoing_download_url = url
        self.ongoing_download_title = title

        url_id = self._identify_urlid_from_url_str(url)
        log.info("Download started for ID: %s Title: %s \nURL: %s", url_id, title, url)
        # print("url_id:", url_id, " url:", url, "\ntitle:", title)
        # create progressbar object
        progress_bar = QtWidgets.QProgressBar()
        progress_bar.setGeometry(QtCore.QRect(60, 60, 118, 23))
        progress_bar.setProperty("value", 0)
        progress_bar.setObjectName(f"{url_id}_progressBar")
        # add widget to twf
        it_w_dict = self.twf.itemwidget_dict.copy()
        track_list = it_w_dict["track_list"]
        track_list.append([url_id, "DL Status"])
        widget_list = it_w_dict["widget_list"]
        widget_list.append(progress_bar)
        it_w_dict.update({"track_list": track_list})
        it_w_dict.update({"widget_list": widget_list})
        self.twf.set_items_widgets(it_w_dict)

        self._main_refresh_tablewidget()

    def _identify_urlid_from_url_str(self, url_str: str) -> str:
        """Gets the URL id from the url and thread index information

        Args:
            url_str (str): thread streig with "th_index url"

        Returns:
            str: url id
        """
        url_splitted = url_str.split(" ")
        url_id = None
        if len(url_splitted) == 2:
            thread_index = url_splitted[0]
            the_url = url_splitted[1]
            for thread_tuple in self.threads_event_list:
                map_list = thread_tuple[3]
                thread_index_url_id_list = self._identify_thread_index_url_id(map_list)
                for th_index, th_url_id in thread_index_url_id_list:
                    # print("&&&&&&&&&&&&&&&&&&& === ",th_index,th_url_id)
                    if th_index == thread_index and self.url_struct[th_url_id]["URL"] == the_url:
                        url_id = th_url_id
                        break
                if url_id:
                    break
        return url_id

    def _pytubefix_download_end(self, url: str, title: str, filename: str):
        """Receives Signal form Pytube fix when a Download is ended

        Args:
            url (str): url of download
            title (str): title of the download
            filename (str): output filename
        """
        # print("========== >>>>>> Main got Signal End <<<<<<< ==========  \n" * 5)
        # print("url:", url, "\ntitle:", title)
        if url == self.ongoing_download_url:
            self.ongoing_download_url = None
            self.ongoing_download_title = None
        url_id = self._identify_urlid_from_url_str(url)
        # msg= f"Download finished for ID: {url_id} Title: {title} \nURL: {url} \nFile: {filename}"
        log.info("Download finished for ID: %s Title: %s \nURL: %s \nFile: %s", url_id, title, url, filename)
        # Set new Filename
        self.url_struct[url_id]["File Name"] = filename
        # add widget to twf
        it_w_dict = self.twf.itemwidget_dict.copy()
        track_list = it_w_dict["track_list"]
        widget_list = it_w_dict["widget_list"]
        # remove tracked objects
        for nnn, track in enumerate(track_list):
            if self._is_same_list(track, [url_id, "DL Status"]):
                track_list.pop(nnn)
                widget_list.pop(nnn)
        self._add_remove_downloading_icons_([url_id], False, None)
        self._add_remove_downloading_icons_([url_id], True, self.icon_main)
        it_w_dict.update({"track_list": track_list})
        it_w_dict.update({"widget_list": widget_list})
        self.twf.set_items_widgets(it_w_dict)

        self._main_refresh_tablewidget()

    def _pytubefix_log(self, log_msg: str):
        """Logs message from pytubefix

        Args:
             log_msg (str): message
        """
        if "error" in log_msg.lower():
            if self.ongoing_download_title:
                log.error("Error while downloading %s", self.ongoing_download_title)
                self.ongoing_download_title = None
                self.ongoing_download_url = None
            log.error(log_msg)
        elif "warning" in log_msg.lower():
            log.warning(log_msg)
        else:
            log.info(log_msg)

    def get_general_config(self):
        """Returns the configuration set in yml file"""
        self.default_config_path = self.app_path + os.sep + "config" + os.sep + "cfg.yml"
        return self.open_configuration_yml_file(self.default_config_path)

    def open_configuration_yml_file(self, path_config_file):
        """Opens configuration file in yml format"""
        path_config = ""
        try:
            with open(path_config_file, encoding="UTF-8") as file:
                path_config = yaml.load(file, Loader=yaml.SafeLoader)
                log.info("Environment configuration loaded")
                self.path_config_file = path_config_file
        except FileNotFoundError:
            log.error("Environment configuration file not found at %s", path_config_file)
            self.a_dialog.send_critical_msgbox(
                "Configuration File not Found!", "Please select location of configuration File"
            )
            errpath = self.a_dialog.open_file_dialog("7")  # 7->yml Files (*.yml)
            if errpath is None:
                with open(errpath, encoding="UTF-8") as file:
                    path_config = yaml.load(file, Loader=yaml.SafeLoader)
                    log.info("Environment configuration loaded")
                    log.warning("Save configuration path as %s to not be prompted for a file", self.default_config_path)
            else:
                raise
            # print(f"Create new {config_file} file?")
            # input_config(config_parameters)
            # generate_config_file(config_parameters)
        return path_config

    def _connect_actions(self):
        """Connect all objects"""
        self.lineEdit_url.textChanged.connect(self._lineedit_url_changed)
        self.actionAbout.triggered.connect(self.show_aboutbox)
        self.actionOpen_URL_list.triggered.connect(self.open_url_list)
        self.actionSave_URL_list.triggered.connect(self.save_url_list)
        self.actionSet_Path.triggered.connect(self.set_download_path)
        self.actionShow_Log.triggered.connect(self._open_log_dialog)
        self.pushButton_url.pressed.connect(self._pushbutton_url_pressed)
        self.pushButton_2.pressed.connect(self._open_windows_explorer)
        self.pushButton_5.pressed.connect(self._clear_table_widget_2)
        self.pushButton_4.pressed.connect(lambda: self._download_selected_items(self.get_id_list()))
        self.pushButton_3.pressed.connect(self._set_dl_enable)

        # right click menu

        self.tableWidget_url.customContextMenuRequested.connect(self._table_item_right_clicked)

    def _open_log_dialog(self):
        path_to_file = LOG_PATH + os.sep + "__yt_pytubefix_gui__.log"
        self.log_dia = class_log_dialog.log_dialog(path_to_file, self.icon_log)
        self.log_text_box = class_log_dialog.QTextEditLogger(self.log_dia.ld_ui.textEdit)
        # You can format what is printed to text box
        self.log_text_box.setFormatter(file_formatter)
        self.log_text_box.setLevel(logging.INFO)  # getattr(logging,self.log_dia.log_level))
        logging.getLogger().addHandler(self.log_text_box)
        self.log_dia.st.signal_ld_logging_level[str].connect(self._set_new_logging_level_from_dialog)
        self.log_dia.ld_ui.pushButton_log_clear.setIcon(self.icon_clear)

    def _set_new_logging_level_from_dialog(self, text):
        print(text)
        self.log_dia.write_file_to_log(self.log_dia.pathandfile)
        # self.log_text_box.setLevel(getattr(logging,self.log_dia.log_level))

    def _set_dl_enable(self):
        """Sets all enabled/disabled 'DL Enable'"""
        all_id_list = self.get_id_list()
        if len(all_id_list) == 0:
            return
        dl_en_list = self._get_download_enabled_list()
        if len(all_id_list) == len(dl_en_list) or len(dl_en_list) == 0:  # all true or all false
            for an_id in all_id_list:
                b_val = bool(self.url_struct[an_id]["DL Enable"])
                self.url_struct[an_id]["DL Enable"] = not b_val
        elif len(all_id_list) > len(dl_en_list) and len(dl_en_list) != 0:
            for an_id in all_id_list:
                if an_id not in dl_en_list:
                    b_val = bool(self.url_struct[an_id]["DL Enable"])
                    self.url_struct[an_id]["DL Enable"] = not b_val
        self._main_refresh_tablewidget()

    def _open_windows_explorer(self):
        """Opens windows explorer in download path"""
        self.a_dialog.explore(self.download_path)

    def _clear_table_widget_2(self):
        """Removes items from the twf2 table"""
        self.url_struct_results = {}
        self._main_refresh_tablewidget2()

    # Right click Menu
    def _table_results_item_right_clicked(self, track: list, apos: QtCore.QPoint):
        """Displays right click menu where item was right clicked

        Args:
            track (list): track of item
            apos (QtCore.QPoint): global position of event
        """
        id_key_list, track_list = self._get_id_key_list_from_selection_results()

        log.debug(
            "TW results Rightclick Selected->  id_key_list: %s, track_list %s, track %s", id_key_list, track_list, track
        )
        if len(track) == 0:
            return
        self.item_menu = QtWidgets.QMenu()
        menu_item01 = self._add_action_to_menu(f"Play File {track[0]}", False, self.icon_play)
        self.item_menu.addSeparator()
        menu_item02 = self._add_action_to_menu(f"Delete File {track[0]}", False, self.icon_bin)
        self.item_menu.addSeparator()
        if len(id_key_list) == 0:
            menu_item01.setEnabled(False)
            menu_item02.setEnabled(False)
        if len(id_key_list) > 0:
            menu_item01.setEnabled(True)
            menu_item01.triggered.connect(lambda: self._play_file(track))
            menu_item02.setEnabled(True)
            menu_item02.triggered.connect(lambda: self._remove_file(track))
        self.item_menu.move(apos)
        self.item_menu.show()

    # Right click Menu
    def _table_item_right_clicked(self, track: list, apos: QtCore.QPoint):
        """Displays right click menu where item was right clicked

        Args:
            track (list): track of item
            apos (QtCore.QPoint): global position of event
        """
        id_key_list, track_list = self._get_id_key_list_from_selection()

        log.debug("Rightclick Selected->  id_key_list: %s, track_list %s, track %s", id_key_list, track_list, track)
        if len(track) == 0:
            return
        self.item_menu = QtWidgets.QMenu()
        menu_item01 = self._add_action_to_menu(f"Toggle {track}", False, self.icon_toggle)
        self.item_menu.addSeparator()
        menu_item10 = self._add_action_to_menu(f"Set Filename {track[0]}", True, self.icon_save_file)
        menu_item11 = self._add_action_to_menu(f"Set Download Path {id_key_list}", True, self.icon_download_folder)
        self.item_menu.addSeparator()
        menu_item20 = self._add_action_to_menu(f"Dump info {track[0]}", True, self.icon_info)
        menu_item22 = self._add_action_to_menu(f"Save Captions {track[0]}", True, self.icon_save_file)
        self.item_menu.addSeparator()
        menu_item21 = self._add_action_to_menu(f"Download {id_key_list}", True, self.icon_download_selected)
        self.item_menu.addSeparator()
        menu_item40 = self._add_action_to_menu(f"Remove {id_key_list}", True, self.icon_minus)
        self.item_menu.addSeparator()
        menu_item60 = self._add_action_to_menu("Download All", True, self.icon_download_all)
        self.item_menu.addSeparator()
        menu_item61 = self._add_action_to_menu("Remove All", True, self.icon_clear)

        if len(id_key_list) == 0:
            menu_item10.setEnabled(False)
            menu_item11.setEnabled(False)
            menu_item20.setEnabled(False)
            menu_item21.setEnabled(False)
            menu_item22.setEnabled(False)
            menu_item40.setEnabled(False)
            menu_item60.setEnabled(False)
            menu_item61.setEnabled(False)

        # itm = self.twf.get_item_from_track(track)
        # mask = self.twf.get_mask_for_item(itm)
        value_of_rc = self.twf.get_tracked_value_in_struct(track, self.url_struct)
        is_itm_bool = self.twf.check_restrictions.check_type(str(bool), value_of_rc, True)
        if is_itm_bool:
            menu_item01.setEnabled(True)
            menu_item01.triggered.connect(lambda: self._toggle_bool_item(track))

        if len(id_key_list) > 0:
            menu_item10.setEnabled(True)
            menu_item10.triggered.connect(lambda: self._select_special_filename_path(track))

            menu_item11.setEnabled(True)
            menu_item11.triggered.connect(lambda: self._select_special_download_path(id_key_list))

            menu_item40.setEnabled(True)
            menu_item40.triggered.connect(lambda: self._remove_url_items(id_key_list, True))

            menu_item61.triggered.connect(lambda: self._remove_url_items(self.get_id_list(), True))

            menu_item20.setEnabled(True)
            menu_item20.triggered.connect(lambda: self._dump_information(track))
            menu_item21.setEnabled(True)
            menu_item21.triggered.connect(lambda: self._download_selected_items(id_key_list))
            menu_item22.setEnabled(True)
            menu_item22.triggered.connect(lambda: self._log_captions(track))
            # Download all
            menu_item60.triggered.connect(lambda: self._download_selected_items(self.get_id_list()))

        # print("Position:",apos)
        # parentPosition = self.tableWidget_url.mapToGlobal(QtCore.QPoint(0, 0))
        # self.item_menu.move(parentPosition + apos)
        # position is already global
        self.item_menu.move(apos)
        self.item_menu.show()

    def _add_action_to_menu(self, text: str, is_enabled: bool, an_icon: QtGui.QIcon = None):
        """_summary_

        Args:
            text (str):text of menu
            an_icon (QtGui.QIcon, optional): Icon. Defaults to None.

        Returns:
            QAction: menu action
        """
        menu_itemxx = self.item_menu.addAction(text)
        if an_icon:
            menu_itemxx.setIcon(an_icon)
        menu_itemxx.setEnabled(is_enabled)
        return menu_itemxx

    def _get_download_enabled_list(self) -> list:
        """Gets the list of DL Enable items

        Returns:
            list: list of ids Download enabled
        """
        dl_enabled_list = []
        for an_id in self.get_id_list():
            if self.url_struct[an_id]["DL Enable"]:
                dl_enabled_list.append(an_id)
        return dl_enabled_list

    def _table_item_comboboxindexchanged(self, index: int, currenttxt: str, track: list):
        """Sets selected resoulution on index changed

        Args:
            index (int): index of combo element
            currenttxt (str): selected text
            track (list): track list of item in table
        """
        print("&& " * 50, index, currenttxt, track)
        # try:
        #     _=index
        #     url_id=track[0]
        #     url=self.url_struct[url_id]["URL"]
        #     prog=self._get_available_resolutions_progressive(url)
        #     adapt=self._get_available_resolutions_adaptive(url)
        #     sel_track = [url_id, "Selected Resolution Codec"]
        #     for ppp in prog + adapt:
        #         if currenttxt == str(ppp):
        #             print(sel_track, currenttxt)
        #             self.twf.set_tracked_value_to_dict(sel_track, currenttxt, self.url_struct, "", False)
        #             print(self.url_struct[url_id]["Selected Resolution Codec"])
        #             # self._main_refresh_tablewidget()
        #             # print("------> were set")
        #             # self._update_shared_struct_options()
        #             # print(self.url_struct_options[url_id]["selected_resolution"])
        #             # print("------> options updated")
        #             # self._main_refresh_tablewidget()
        #             # print("------> refreshed")
        #             break
        # except Exception as eee:
        #     print(eee)
        print("&& " * 50, "----->exit here")

    # def _get_resolution_combobox_value(self,url_id) -> str:
    #     """Gets actual value in the combobox for url_id

    #     Args:
    #         url_id (any): url id

    #     Returns:
    #         str: combobox selection text
    #     """
    #     current_text=None
    #     it_w_dict = self.twf.itemwidget_dict
    #     track_list = it_w_dict["track_list"]
    #     widget_list = it_w_dict["widget_list"]
    #     for lll,(track,wiget) in enumerate(zip(track_list,widget_list)):
    #         if self._is_same_list([url_id, "Resolution"],track):
    #             if isinstance(wiget,QtWidgets.QComboBox):
    #                 try:
    #                     index=wiget.currentIndex()
    #                     current_text=wiget.itemText(index)
    #                 except RuntimeError as err:
    #                     log.error("Can't read Combobox: %s",err)
    #                 break
    #     return current_text

    def _add_resolution_combobox(self, url_id, url: str):
        """Adds combobox to item with the resolution selection

        Args:
            url_id (any): Url id of item
            url (str): url to search for resolutions
        """

        combobox = QtWidgets.QComboBox()
        # Tablewidget deletes objects after using setCellwidget, you can not set different comboboxes
        # now combobox objects are delegated to cell information.
        first_progressive = None
        for nnn, ppp in enumerate(self._get_available_resolutions_progressive(url)):
            if nnn == 0:
                first_progressive = str(ppp)
            combobox.addItem(str(ppp))
        for nnn, aaa in enumerate(self._get_available_resolutions_adaptive(url)):
            combobox.addItem(str(aaa))

        # set best progressive as default
        if first_progressive:
            index = combobox.findText(first_progressive, QtCore.Qt.MatchFixedString)
            combobox.setCurrentIndex(index)
            track = [url_id, "Resolution"]
            self.twf.set_tracked_value_to_dict(track, first_progressive, self.url_struct, "", False)
            # track = [url_id, "Selected Resolution Codec"]
            # self.twf.set_tracked_value_to_dict(track, first_progressive, self.url_struct, "", False)

        # add widget to twf
        it_w_dict = self.twf.itemwidget_dict
        track_list = it_w_dict["track_list"]
        track_list.append([url_id, "Resolution"])
        widget_list = it_w_dict["widget_list"]
        widget_list.append(combobox)
        it_w_dict.update({"track_list": track_list})
        it_w_dict.update({"widget_list": widget_list})
        self.twf.set_items_widgets(it_w_dict)
        print(self.twf.itemwidget_dict)

    def _add_remove_downloading_icons_(
        self, id_key_list: list, add_to: bool, the_icon: QtGui.QIcon = None, the_twf: int = 1
    ):
        """Adds icons to being dowloaded items

        Args:
            id_key_list (list): items to download
            add_to (bool) : True adds icons,False remove them
            the_twf (int): Tablewidget twf=1 and twf2=2. Defauelt 1
        """
        it_icon_dict = {}
        if the_twf == 1:
            it_icon_dict = self.twf.icon_dict.copy()
        elif the_twf == 2:
            it_icon_dict = self.twf2.icon_dict.copy()
        track_list = it_icon_dict["track_list"]
        icon_list = it_icon_dict["icon_list"]
        if add_to and the_icon is not None:
            # add icon to twf
            for id_key in id_key_list:
                track = [id_key, "DL Status"]
                track_list.append(track)
                icon_list.append(the_icon)
            it_icon_dict.update({"track_list": track_list})
            it_icon_dict.update({"icon_list": icon_list})
        elif not add_to:
            pos_to_del_list = []
            for id_key in id_key_list:
                del_track = [id_key, "DL Status"]
                for pos, track in enumerate(track_list):
                    if self._is_same_list(del_track, track):
                        pos_to_del_list.append(pos)
            new_track_list = []
            new_icon_list = []
            for pos, (a_track, an_icon) in enumerate(zip(track_list, icon_list)):
                if pos not in pos_to_del_list:
                    new_track_list.append(a_track)
                    new_icon_list.append(an_icon)
            it_icon_dict = {}
            it_icon_dict.update({"track_list": new_track_list})
            it_icon_dict.update({"icon_list": new_icon_list})
        if the_twf == 1:
            self.twf.set_items_icons(it_icon_dict)
            self._main_refresh_tablewidget()
        elif the_twf == 2:
            self.twf2.set_items_icons(it_icon_dict)
            self._main_refresh_tablewidget2()

    def _download_selected_items(self, id_key_list: list):
        """
        Downloads the items in the list, starts a thread for each download
        """
        dl_enabled_list = self._get_download_enabled_list()
        id_list = []
        for key in id_key_list:
            if key in dl_enabled_list:
                id_list.append(key)
        if len(id_key_list) != len(id_list):
            log.info("Some URLs are not Download enabled, downloading only %s", id_list)
        id_key_list = id_list  # Download only enabled
        self._add_remove_downloading_icons_(id_key_list, True, self.icon_download_selected)
        # prepare dict
        if len(self.threads_event_list) <= 5 and len(id_key_list) > 0:
            file_properties_dict = {}
            map_list = []
            for index, url_id in enumerate(id_key_list):
                file_properties_dict.update({str(index): self.url_struct_options[url_id]})
                map_list.append((url_id, file_properties_dict))
            self.threads_mapping_dict.update({})
            kill_ev = threading.Event()
            kill_ev.clear()
            cycle_time = 0.1
            local_st = class_signal_tracker.SignalTracker()
            q_dl_stream = thread_download_pytubefix.ThreadQueueDownloadStream(
                file_properties_dict, cycle_time, kill_ev, local_st
            )
            local_st.signal_th2m_to_log[str].connect(self._pytubefix_log)
            local_st.signal_th2m_download_start[str, str].connect(self._pytubefix_download_start)
            local_st.signal_th2m_download_end[str, str, str].connect(self._pytubefix_download_end)
            local_st.signal_th2m_on_progress[str, float].connect(self._pytubefix_download_progress)
            local_st.signal_th2m_thread_end[bool].connect(self._thread_exit_event)
            self.threads_event_list.append((kill_ev, local_st, q_dl_stream, map_list))
            q_dl_stream.start()
            log.info("Thread started with %s", id_key_list)
            # Todo: Disable editing the objects in twf while downloading!!!!!!!!!!!!!!!!!!!
            # hind Qt.EditRole
            # in c item->setFlags(item->flags() & ~Qt::ItemIsEditable);

            # self.twf.get_track_of_item_in_table()
            # for key in id_key_list:
            #     row_dict=self.url_struct[key]
            #     for col_key in row_dict:
            #         itm, _, _, _=self.twf.get_item_from_track([key,col_key])
            #         if isinstance(itm,QtWidgets.QTableWidgetItem):
            #             print("############### flags-->",int(itm.flags()))
            #             #itm.setFlags(itm.flags() & ~QtCore.Qt.ItemIsEditable)

            # self.twf.tablewidgetobj.verticalHeader().setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
            # self.twf.tablewidgetobj.verticalHeader().setEditTriggers(QtWidgets.QAbstractItemView.setEditTriggers())
            # print(q_dl_stream.is_alive())
        elif len(self.threads_event_list) >= 5:
            log.warning("There are already 5 downloading threads simultaneously!")
        else:
            log.warning("There is nothing to Download!")

    def _thread_exit_event(self, fine_exit: bool):
        """Thread ended and exit signal

        Args:
            fine_exit (bool): Ended normally or was killed
        """
        log.info("========== >>>>>> Thread Finished <<<<<<< ==========  ")
        if fine_exit:
            log.info("Tread Finalized correctly")
        th_ev_list = self.threads_event_list.copy()
        log.info("Number of running threads: %s", len(self.threads_event_list))
        time.sleep(1)
        for list_index, threads in enumerate(th_ev_list):
            q_dl_stream = threads[2]
            # print("Is thread alive? ->",list_index, q_dl_stream.is_alive())
            if not q_dl_stream.is_alive():
                # print("Is thread alive? ->",list_index, q_dl_stream.is_alive())
                map_list = threads[3]
                self._handle_finished_dowloads_table(map_list)
                q_dl_stream.join()
                self.threads_event_list.pop(list_index)
        log.info("Number of running threads: %s", len(self.threads_event_list))

    def _handle_finished_dowloads_table(self, map_list: list[tuple]):
        """Removes from table 1 and sets to table 2 finished downloads tracking
            the thread and the url_id in list

        Args:
            map_list (list[tuple]): list of downloaded contents in the thread
                        each tuple contains (url_id, file_properties_dict)
                        the file_properties_dict contains the same information as:
                        self.url_struct_options[url_id], but the key is the thread index.
        """
        # print(map_list)
        thread_index_url_id_list = self._identify_thread_index_url_id(map_list)
        url_id_list = []
        for pair in thread_index_url_id_list:
            url_id_list.append(pair[1])
            # print("url_id->", pair[1], "thrindex->", pair[0])
        self._add_remove_downloading_icons_(url_id_list, False, None)
        self._add_item_to_url_struct_results(url_id_list)
        self._remove_url_items(url_id_list, False)

    def _add_item_to_url_struct_results(self, url_id_list: list):
        """Adds item to url_struct_results dictionary and to twf2"""
        for url_id in url_id_list:
            results_dict = {}
            for item, item_value in self.url_struct[url_id].items():
                if item not in ["DL Enable"]:
                    results_dict.update({item: item_value})
            results_id_list = self.a_ufun.get_dict_key_list(self.url_struct_results)
            results_url_id = self.a_ufun.get_unique_id(url_id, results_id_list, "URL")
            self.url_struct_results.update({results_url_id: results_dict})
            # self.url_id_counter = self.url_id_counter + 1
        self.twf2.set_items_icons()
        results_id_list = self.a_ufun.get_dict_key_list(self.url_struct_results)
        self._add_remove_downloading_icons_(results_id_list, True, self.icon_main, 2)
        self._main_refresh_tablewidget2()

    def _main_refresh_tablewidget2(self):
        """Refresh the tablewidget twf2"""
        self.twf2.data_struct = self.url_struct_results
        self.twf2.set_show_dict()
        self.twf2.refresh_tablewidget(self.twf2.show_dict, self.twf2.modelobj, self.twf2.tablewidgetobj)

    def _identify_thread_index_url_id(self, map_list: list[tuple]) -> list[tuple]:
        """Gets the URLid and Thread index pairs

        Args:
            map_list (list[tuple]): list of downloaded contents in the thread
                        each tuple contains (url_id, file_properties_dict)
                        the file_properties_dict contains the same information as:
                        self.url_struct_options[url_id], but the key is the thread index.

        Returns:
            list[tuple]: (thread_index,url_id)
        """
        thread_index_url_id_list = []
        for th_map in map_list:
            url_id = th_map[0]
            # thread_keys = self.twf.get_dict_key_list(th_map[1])
            thread_index = None
            for key, item_value in th_map[1].items():
                same_values = True
                for item_key in item_value:
                    if str(th_map[1][key][item_key]) != str(self.url_struct_options[url_id][item_key]):
                        same_values = False
                        break
                if same_values:
                    thread_index = key
                    break
            thread_index_url_id_list.append((thread_index, url_id))
        return thread_index_url_id_list

    def _get_complete_output_file(self, track: list) -> str:
        """Gets the full path to item  in result list

        Args:
            track (list): track of the result item

        Returns:
            str: path and file string if file exists, None if it does not exist
        """
        url_id = track[0]
        # url=self.url_struct_results[url_id]["URL"]
        filename = self.url_struct_results[url_id]["File Name"]
        title = self.url_struct_results[url_id]["File Name"]
        fileprefix = self.url_struct_results[url_id]["File Name Prefix"]
        dl_path = self.url_struct_results[url_id]["Download Path"]

        if not filename:
            filename = (
                self.ptf.clean_filename(
                    title, "áéíóúüöäÜÖÄÁÉÍÓÚçÇabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_ -"
                )
                + ".mp4"
            )
        if not dl_path:
            dl_path = self.download_path
        filename = fileprefix + filename
        complete_output_path = os.path.join(dl_path, filename)
        if not os.path.exists(complete_output_path):
            log.warning("File {complete_output_path} does not exist! :(")
            return None
        return complete_output_path

    def _play_file(self, track: list):
        """
        Opens a video file using the default media player.

        Args:
            video_path (str): The path to the video file.
        """
        video_path = self._get_complete_output_file(track)
        if not video_path:
            return
        # Check if the operating system is Windows or Linux
        if os.name == "nt":  # Windows
            # Use the default media player for Windows
            log.info("Opening in default Media Player...")
            os.startfile(video_path)
        elif os.name in ["posix", "linux"]:  # Linux and macOS
            # Use the `xdg-open` command to open the file with a suitable application
            log.info("Opening video using xdg-open...")
            subprocess.run(["xdg-open", video_path], check=False)
        else:
            raise NotImplementedError(f"Unsupported operating system: {os.name}")

    def _remove_file(self, track: list, prompt_msgbox: bool = True):
        """Removes downloaded file from computer

        Args:
            track (list): item to remove
            prompt_msgbox (bool, optional): Prompt message box yes/no to delete. Defaults to True.
        """
        url_id = track[0]
        url = self.url_struct_results[url_id]["URL"]
        title = self.url_struct_results[url_id]["File Name"]
        complete_output_path = self._get_complete_output_file(track)
        if not complete_output_path:
            return
        if prompt_msgbox:
            msg_title = "Removing Downloaded File"
            msg_ = f"Are you sure you want to remove {url_id} File: \n{complete_output_path} \n {url} \n {title} "
            if not self.a_dialog.send_question_yes_no_msgbox(msg_title, msg_):
                return
        try:
            os.remove(complete_output_path)
            log.info(f"Removed File {complete_output_path} .. bye bye")
            self._remove_url_items_results([url_id])
        except (FileExistsError, FileNotFoundError, PermissionError) as eee:
            log.error("File could not be deleted: %s", eee)

    def _log_captions(self, track: list):
        """Prints caption to log

        Args:
            track (list): url track
        """
        self.a_dialog.set_default_dir(self.download_path)
        filename = self.a_dialog.save_file_dialog(2)
        # language='en'
        if filename:
            self._enable_disable_obj_on_process(False)
            url_id = track[0]
            url = self.url_struct[url_id]["URL"]
            self.ptf.save_subtitles_to_file(url, filename, None)  # will save all
        self._enable_disable_obj_on_process(True)

    def _dump_information(self, track: list):
        """Reads info from file and dumps it into a json file.

        Args:
            track (list): url track
        """
        filename = self.a_dialog.save_file_dialog(8)
        if filename:
            self._enable_disable_obj_on_process(False)
            url_id = track[0]
            url = self.url_struct[url_id]["URL"]
            info_dict = self.ptf.get_url_info(url)
            info_dict = self.a_ufun.convert_types_to_stringsin_dict(info_dict, pytubefix.Caption)
            info_dict = self.a_ufun.convert_types_to_stringsin_dict(info_dict, pytubefix.CaptionQuery)

            info_dict = self.a_ufun.convert_types_to_stringsin_dict(info_dict, pytubefix.metadata.YouTubeMetadata)
            info_dict = self.a_ufun.convert_types_to_stringsin_dict(info_dict, datetime.datetime)

            # for iiinfo in info_dict:
            #     print(iiinfo, "-->", type(info_dict[iiinfo]), str(info_dict[iiinfo]))
            fn = self.a_dialog.extract_filename(filename, False) + ".json"
            path = self.a_dialog.extract_path(filename)
            filename = os.path.join(path, fn)
            try:
                # python dictionary with key value pairs
                # create json object from dictionary
                js = json.dumps(info_dict, default=vars)
                # open file for writing, "w"
                with open(filename, "w", encoding="utf-8") as fff:
                    # write json object to file
                    fff.write(js)
                    # close file
                    fff.close()
                log.info("Saved File: %s", filename)

            except (PermissionError, FileExistsError, FileNotFoundError) as e:
                log.error("Json File :%s was not saved", filename)
                log.error(e)
            self._enable_disable_obj_on_process(True)

    def _select_special_filename_path(self, track: list):
        """Sets a different download path than the Default path"""
        self.a_dialog.set_filter("mp4", "All Files (*);;Video Files (*.mp4)", "Video Files (*.mp4)", False)
        url_id = track[0]
        if self.url_struct[url_id]["Download Path"]:
            path_def = self.url_struct[url_id]["Download Path"]
        else:
            path_def = self.download_path
        self.a_dialog.set_default_dir(path_def)
        filenamepath = self.a_dialog.save_file_dialog("mp4")
        if filenamepath:
            dl_dir = self.a_dialog.extract_path(filenamepath, True)
            filename = self.a_dialog.extract_filename(filenamepath, True)
            download_path = ""
            if len(dl_dir) > 0:
                if self.download_path != dl_dir:
                    download_path = dl_dir
                else:
                    download_path = ""
                    log.info("Same path as default!")
                log.info("Setting to %s Download dir: %s", url_id, dl_dir)
                track = [url_id, "Download Path"]
                self.twf.set_tracked_value_to_dict(track, str(download_path), self.url_struct, "", False)
            log.info("Setting to %s File Name: %s", url_id, filename)
            track = [url_id, "File Name"]
            self.twf.set_tracked_value_to_dict(track, str(filename), self.url_struct, "", False)
            # mask returns it to ""
            # self.twf.set_value_and_trigger_data_change(track,str(download_path),str(str),"")
            # Refresh and update
            self._main_refresh_tablewidget()
            self._update_shared_struct_options()
        else:
            # restore default path
            self.a_dialog.set_default_dir(self.download_path)

    def _select_special_download_path(self, id_key_list: list):
        """Sets a different download path than the Default path"""
        dl_dir = self.a_dialog.open_directory_dialog(caption="Select Download directory", directory=self.download_path)
        download_path = ""
        if len(dl_dir) > 0:
            for url_key in id_key_list:
                if self.download_path != dl_dir[0]:
                    download_path = dl_dir[0]
                else:
                    download_path = ""
                    log.info("Same path as default!")
                log.info("Setting to %s Download dir: %s", url_key, dl_dir[0])
                track = [url_key, "Download Path"]
                self.twf.set_tracked_value_to_dict(track, str(download_path), self.url_struct, "", False)
                # mask returns it to ""
                # self.twf.set_value_and_trigger_data_change(track,str(download_path),str(str),"")
        # Refresh and update
        self._main_refresh_tablewidget()
        self._update_shared_struct_options()
        # print(self.url_struct_options)

    def _is_same_list(self, list1: list, list2: list) -> bool:
        """Compares two lists

        Args:
            list1 (list): list1
            list2 (list): list2

        Returns:
            bool: True if the same,False if different
        """
        if len(list1) != len(list2):
            return False
        for iii, jjj in zip(list1, list2):
            if iii != jjj:
                return False
        return True

    def _remove_url_items(self, id_key_list: list, prompt_msgbox: bool = False):
        """Removes items from table

        Args:
            id_key_list (list): list of items to remove
            prompt_msgbox (bool, optional): Prompt message box yes/no to delete. Defaults to False.
        """
        if prompt_msgbox:
            if self._is_same_list(self.get_id_list(), id_key_list):
                msg_title = "Removing ALL URLS"
                msg_ = f"Are you sure to remove ALL items: {len(id_key_list)} in total"
            else:
                msg_title = "Removing URLS"
                msg_ = f"Are you sure to remove items {id_key_list}"
            if not self.a_dialog.send_question_yes_no_msgbox(msg_title, msg_):
                return

        for a_key in id_key_list:
            self.url_struct = self.a_ufun.get_dict_wo_key(self.url_struct, a_key)
            self.url_struct_options = self.a_ufun.get_dict_wo_key(self.url_struct_options, a_key)
        self._main_refresh_tablewidget()

    def _remove_url_items_results(self, id_key_list: list, prompt_msgbox: bool = False):
        """Removes items from table results

        Args:
            id_key_list (list): list of items to remove
            prompt_msgbox (bool, optional): Prompt message box yes/no to delete. Defaults to False.
        """
        if prompt_msgbox:
            if self._is_same_list(self.a_ufun.get_dict_key_list(self.url_struct_results), id_key_list):
                msg_title = "Removing ALL URLS"
                msg_ = f"Are you sure to remove ALL items: {len(id_key_list)} in total"
            else:
                msg_title = "Removing URLS"
                msg_ = f"Are you sure to remove items {id_key_list}"
            if not self.a_dialog.send_question_yes_no_msgbox(msg_title, msg_):
                return

        for a_key in id_key_list:
            self.url_struct_results = self.a_ufun.get_dict_wo_key(self.url_struct_results, a_key)
        self._main_refresh_tablewidget2()

    def _get_available_resolutions_progressive(self, url: str) -> list:
        """Gets the resolutions for progressive download

        Args:
            url (str): the url
        Returns:
            list: [itag,resolution,(codec_video,codec_audio)]
        """
        ys_p, _ = self.ptf.get_streams_available(url)
        resoulutions = []
        if ys_p:
            for ppp in ys_p:
                # print("PRog:",ppp)
                i_tag = self.a_ufun.extract_value("itag=", str(ppp))
                c_aud = self.a_ufun.extract_value("acodec=", str(ppp))
                c_vid = self.a_ufun.extract_value("vcodec=", str(ppp))
                r_vid = self.a_ufun.extract_value("res=", str(ppp))
                if r_vid and r_vid not in resoulutions:
                    resoulutions.append([i_tag, r_vid, (c_vid, c_aud)])
        return resoulutions

    def _get_available_resolutions_adaptive(self, url: str) -> list:
        """Gets the combinations of possible video-audio resolutions for adaptive download

        Args:
            url (str): the url
        Returns:
            list: [(itag_video,itag_audio),(resolution,audiobitrate),(codec_video,codec_audio)]
        """
        _, ys_a = self.ptf.get_streams_available(url)
        resoulutions_vid = []
        resoulutions_aud = []
        if ys_a:
            for ppp in ys_a:
                i_tag = self.a_ufun.extract_value("itag=", str(ppp))
                r_aud = self.a_ufun.extract_value("abr=", str(ppp))
                if r_aud and r_aud not in resoulutions_aud:
                    c_aud = self.a_ufun.extract_value("acodec=", str(ppp))
                    resoulutions_aud.append([i_tag, r_aud, c_aud])
                r_vid = self.a_ufun.extract_value("res=", str(ppp))
                if r_vid and r_vid not in resoulutions_vid:
                    c_vid = self.a_ufun.extract_value("vcodec=", str(ppp))
                    resoulutions_vid.append([i_tag, r_vid, c_vid])
        resoulutions = []
        for vid_res in resoulutions_vid:
            for aud_res in resoulutions_aud:
                resoulutions.append([(vid_res[0], aud_res[0]), (vid_res[1], aud_res[1]), (vid_res[2], aud_res[2])])
        return resoulutions

    def _do_debug_stuff(self, track):
        """do debug stuff"""
        # url=self.url_struct[track[0]]["URL"]
        # ys_p,ys_a=self.ptf.get_streams_available(url)
        # for nnn,ppp in enumerate(ys_p):
        #     print("PRog:",nnn,ppp)
        # for nnn,aaa in enumerate(ys_a):
        #     print("Adap:",nnn,aaa)
        # print("-"*20)
        # for nnn,ppp in enumerate(self._get_available_resolutions_progressive(url)):
        #     print("PRog:",nnn,ppp)
        # print("-"*20)
        # for nnn,aaa in enumerate(self._get_available_resolutions_adaptive(url)):
        #     print("Adap:",nnn,aaa)
        print("7@7" * 20)
        print(track)
        # print(self._get_resolution_combobox_value(track[0]))

    def _toggle_bool_item(self, track: list):
        """Toggles the value of a bool item in the Table

        Args:
            track (list): track of item
        """
        # self._do_debug_stuff(track)
        value_of_rc = self.twf.get_tracked_value_in_struct(track, self.url_struct)
        is_itm_bool = self.twf.check_restrictions.check_type(str(bool), value_of_rc, True)
        if is_itm_bool:
            log.debug("Toggle Triggered %s", track)
            value_of_rc = self.twf.check_restrictions.set_type_to_value(value_of_rc, str(bool), "")
            self.twf.set_value_and_trigger_data_change(track, not value_of_rc, str(bool), "")
        self._main_refresh_tablewidget()

    def _get_id_key_list_from_selection(self) -> tuple[list, list]:
        """Gets a list of keys of the items selected

        Returns:
            tuple[list,list]: list of selected items, list of track lists
        """
        selindex = self.tableWidget_url.selectedIndexes()
        id_key_list = []
        track_list = []
        for selection in selindex:
            itm = self.twf.tablewidgetobj.itemFromIndex(selection)
            id_key = self.twf.get_key_value_from_item(itm)
            # #itm=selection.model().itemFromIndex(selection)
            track = self.twf.get_track_of_item_in_table(itm)
            # track=self.twf.get_key_value_from_row(itm.row())
            # if isinstance(self.twf.data_struct,list):
            #     id_key=self.twf.get([track[0],'ID'])
            # if isinstance(self.twf.data_struct,dict):
            #     id_key=self.get_tracked_value_in_dict([track[0],'ID'])
            if id_key not in id_key_list:
                id_key_list.append(id_key)
                track_list.append(track)
        return id_key_list, track_list

    def _get_id_key_list_from_selection_results(self) -> tuple[list, list]:
        """Gets a list of keys of the items selected for twf2

        Returns:
            tuple[list,list]: list of selected items, list of track lists
        """
        selindex = self.tableWidget_results.selectedIndexes()
        id_key_list = []
        track_list = []
        for selection in selindex:
            itm = self.twf2.tablewidgetobj.itemFromIndex(selection)
            id_key = self.twf2.get_key_value_from_item(itm)
            track = self.twf2.get_track_of_item_in_table(itm)
            if id_key not in id_key_list:
                id_key_list.append(id_key)
                track_list.append(track)
        return id_key_list, track_list

    def _enable_disable_obj_on_process(self, enable: bool):
        """Enables disables objects while processing actions so user can not make UI

        Args:
            enable (bool): Enabled True /disabled False
        """
        self.pushButton_url.setEnabled(enable)
        self.groupBox.setEnabled(enable)
        self.actionAbout.setEnabled(enable)
        self.actionOpen_URL_list.setEnabled(enable)
        self.actionSet_Path.setEnabled(enable)
        self.actionSave_URL_list.setEnabled(enable)

    def _pushbutton_url_pressed(self):
        """On pressed url button add to list"""
        self._enable_disable_obj_on_process(False)
        # fast regex check
        the_link = self.lineEdit_url.text()
        the_link = the_link.strip()
        link_list = self.twf.check_restrictions.string_to_list(the_link)
        if link_list:
            for a_link in link_list:
                if self._check_url_is_valid(a_link):
                    # passed checks
                    self.add_item_to_url_struct(a_link)
        elif self._check_url_is_valid(the_link):
            # passed checks
            self.add_item_to_url_struct(the_link)
        self._enable_disable_obj_on_process(True)

    def _check_url_is_valid(self, url: str) -> bool:
        """Is a pytubefix valid url, checks regex and exists

        Args:
            url (str): url to check

        Returns:
            bool: is valid
        """
        is_valid, _ = self.ptf.is_yt_valid_url(url)
        if not is_valid:
            return False
        # slow html check
        return self.does_url_exist(url)

    def get_id_list(self):
        """Get the ids of the items in view"""
        return self.a_ufun.get_dict_key_list(self.url_struct)

    def is_id_taken(self, an_id) -> bool:
        """Check if the id is taken"""
        idlist = self.get_id_list()
        if an_id in idlist:
            return True
        return False

    def add_item_to_url_struct(self, url: str):
        """Adds item to list"""
        self.twf.tablewidgetobj.clearSelection()
        vid_list, vid_list_url = self.ptf.get_any_yt_videos_list(url)
        for vid_title, vid_url in zip(vid_list, vid_list_url):
            new_id = self.a_ufun.get_unique_id("URL0", self.get_id_list(), "URL")
            self.url_struct.update(
                {
                    new_id: {
                        "Index": self.url_id_counter,  # int(new_id.replace("URL","")),
                        "DL Status": "",
                        "Title": vid_title,
                        "URL": vid_url,
                        "DL Enable": True,
                        "MP3": False,
                        "Skip Existing": True,
                        "Resolution": "",
                        "Timeout sec": 0,
                        "Max Retries": 0,
                        "File Name": "",
                        "File Name Prefix": "",
                        "Download Path": "",
                        # "Selected Resolution Codec":"",
                    },
                }
            )
            self._add_resolution_combobox(new_id, vid_url)
            self.url_id_counter = self.url_id_counter + 1
        # This sets options dict
        self._update_shared_struct_options()
        self._main_refresh_tablewidget()
        # print(self.url_struct)
        # print(self.url_struct_options)
        # res_values=[]
        # for url_id in self.get_id_list():
        #     res_values.append(self.url_struct[url_id]["Resolution"])

        # print("7$"*10+"refreshed->",res_values)

    def _get_request_exceptions_tuple(self) -> tuple:
        """Get exceptions from resource package

        Returns:
            tuple: tuple of exceptions
        """
        exception_list_ini = dir(requests.exceptions)
        exception_list = []
        for except_item in exception_list_ini:
            if "_" not in except_item:
                exception_list.append(except_item)
        exception_tuple = None
        for iii, except_item in enumerate(exception_list):
            if iii == 0:
                exception_tuple = (getattr(requests.exceptions, except_item),)
            else:
                exception_tuple = exception_tuple + (getattr(requests.exceptions, except_item),)
        return exception_tuple

    def does_url_exist(self, url):
        """Check if the given url exists or not"""
        try:
            response = requests.get(url, timeout=10)
        except self._get_request_exceptions_tuple() as eee:
            log.error(eee)
            return False
        if response.status_code == 200:
            return True
        return False

    def open_url_list(self):
        """Opens list of uls"""
        self.open_url_list_from_json(None)

    def open_url_list_from_json(self, a_filename: str = None):
        """Opens a json file and appends it to struct

        Args:
            a_filename (str, optional): input the filename or open dialog if None. Defaults to None.
        """
        if not a_filename:
            a_filename = self.a_dialog.open_file_dialog(8)
        if a_filename is not None:
            try:
                if not os.path.exists(a_filename):
                    raise FileNotFoundError
                with open(a_filename, encoding="utf-8") as fff:
                    data = fff.read()
                # reconstructing the data as a dictionary
                fff.close()
                js_data = json.loads(data)
                self._add_dictionaries_to_struct(js_data)

                log.info("Loaded File: %s", a_filename)
            except (PermissionError, FileExistsError, FileNotFoundError) as e:
                log.error("Json File: %s can not be opened", a_filename)
                log.error(e)

    def _add_dictionaries_to_struct(self, inc_struct):
        """Adds to strcut the input dictionaries"""
        newstruct = {}
        a_struct = self.a_ufun.recursive_copy_dict(inc_struct)
        self._enable_disable_obj_on_process(False)
        try:
            for key in a_struct:
                url_id = self.a_ufun.get_unique_id("URL0", self.get_id_list(), "URL")
                is_valid, what_is = self.ptf.is_yt_valid_url(a_struct[key]["URL"])
                if is_valid and what_is == "video":
                    # this sets the actual structure
                    self.add_item_to_url_struct(a_struct[key]["URL"])
                    # set single items of the structure
                    for item, item_value in a_struct[key].items():
                        self.url_struct[url_id][item] = item_value
                    # self.url_id_counter = self.url_id_counter + 1
                if is_valid and what_is in ["channel", "playlist"]:
                    self.add_item_to_url_struct(a_struct[key]["URL"])

            self._update_shared_struct_options()
            self._main_refresh_tablewidget()

        except (AttributeError, KeyError, IndexError) as eee:
            log.error("Dictionary has incorrect format: %s", eee)
        self._enable_disable_obj_on_process(True)
        return newstruct

    def _main_refresh_tablewidget(self):
        """Refresh the tablewidget"""
        # refresh
        self.twf.data_struct = self.url_struct
        self.twf.set_show_dict()
        self.twf.refresh_tablewidget(self.twf.show_dict, self.twf.modelobj, self.twf.tablewidgetobj)

    def save_url_list(self):
        """Saves to json the list of urls"""
        if len(self.url_struct) > 0:
            self.a_dialog.set_default_dir(self.download_path)
            filename = self.a_dialog.save_file_dialog(8)
            if filename:
                fn = self.a_dialog.extract_filename(filename, False) + ".json"
                path = self.a_dialog.extract_path(filename)
                filename = os.path.join(path, fn)
                try:
                    # python dictionary with key value pairs
                    # create json object from dictionary
                    js = json.dumps(self.url_struct)
                    # open file for writing, "w"
                    with open(filename, "w", encoding="utf-8") as fff:
                        # write json object to file
                        fff.write(js)
                        # close file
                        fff.close()
                    log.info("Saved File: %s", filename)

                except (PermissionError, FileExistsError, FileNotFoundError) as e:
                    log.error("Json File :%s was not saved", filename)
                    log.error(e)

    def set_download_path(self):
        """Sets the path for download and stores the configuration"""
        dl_dir = self.a_dialog.open_directory_dialog(caption="Select Download directory")
        if not dl_dir:
            return
        log.info("Download dir: %s", dl_dir)
        self.general_config["Last_Path_for_Download"] = dl_dir[0]
        self.set_general_config_to_yml_file()
        self.download_path = self.app_path
        if isinstance(self.general_config["Last_Path_for_Download"],list):
            self.download_path = self.general_config["Last_Path_for_Download"][0]
        if isinstance(self.general_config["Last_Path_for_Download"],str):
            self.download_path = self.general_config["Last_Path_for_Download"]
        self.label_DownloadPath.setText(f"Downloading to: {self.download_path}")

    def set_general_config_to_yml_file(self):
        """Saves the general configuration"""
        try:
            if os.path.exists(self.path_config_file):
                with open(self.path_config_file, "w", encoding="UTF-8") as file:
                    yaml.dump(self.general_config, file)
            else:
                raise FileExistsError
        except (FileExistsError, PermissionError, FileNotFoundError, IsADirectoryError, NotImplementedError):
            log.error("Saving yml configuration file!")

    def _lineedit_url_changed(self):
        """When line edit changed"""
        urlexists = self.does_url_exist(self.lineEdit_url.text())
        if urlexists:
            self.lineEdit_url.setToolTip("Exists!")
        else:
            self.lineEdit_url.setToolTip("")

    def _set_splitter_pos(self, pos, per=None):
        """Sets the position of the splitter"""
        sizes = self.splitter.sizes()
        tot = sizes[1] + sizes[0]
        if per is not None and 0 <= per <= 1:  # per >= 0 and per <= 1:
            pos = int(tot * per)
            newsizes = [pos, tot - pos]
            self.splitter.setSizes(newsizes)
        elif pos <= tot:
            newsizes = [pos, tot - pos]
            self.splitter.setSizes(newsizes)
        self.splitter.adjustSize()

    def _set_path_labels(self):
        """Set texts and labels in Gui"""
        self.lineEdit_url.setToolTip(
            "Type YT url,channel,playlist or comma separated list in format '[URL1, ..., URLN]'"
        )
        self.groupBox.setTitle("List of URLs:")
        self.groupBox_2.setTitle("Processed URLs:")
        self.label_DownloadPath.setText(f"Downloading to: {self.download_path}")
        self.pushButton_url.setText("add")
        self.pushButton_2.setText("Explorer")
        self.pushButton_5.setText("Clear Processed URLs")
        self.pushButton_4.setText("Download all")
        self.pushButton_3.setText("Toggle DL Enable")

    def show_aboutbox(self):
        """Shows About box"""
        title = "About YT Downloader PytubeFix Tool"
        amsg = (
            '<h1 style="font-size:160%;color:red;">Programmed with coffee and love</h1>'
            + '<h1 style="font-size:160%;color:black;">by '
            + __author__
            + '</h1> <p style="color:black;">github: '
            + __gitaccount__
            + '</p> <p style="color:black;"> Current version: V'
            + __version__
            + '</p> <p style="color:black;">Creation date: '
            + __creationdate__
            + '</p> <p style="color:black;">pytubefix: '
            + __pytubefix__
            + " V:"
            + str(version("pytubefix"))
            + "</p>"
        )
        # msgbox = QMessageBox.about(main_window,title,amsg)
        msgbox = QtWidgets.QMessageBox()
        msgbox.setWindowTitle(title)
        # msgbox.setIcon(QMessageBox.Information)
        msgbox.setWindowIcon(self.icon_main)
        if self.icon_main_pixmap is not None:
            thepm = self.icon_main_pixmap.scaled(
                160,
                160,
                QtCore.Qt.KeepAspectRatio,
                QtCore.Qt.TransformationMode.SmoothTransformation,  # pylint: disable= no-member
            )
            # QtCore.Qt.FastTransformation)
            # thepm.scaledToWidth(90,QtCore.Qt.TransformationMode.SmoothTransformation)
            #  QtCore.Qt.TransformationMode.SmoothTransformation) #QtCore.Qt.AspectRatioMode.KeepAspectRatio)
            msgbox.setIconPixmap(thepm)
        msgbox.setText(amsg)
        msgbox.setTextFormat(QtCore.Qt.RichText)
        msgbox.exec_()


class MyWindow(QtWidgets.QMainWindow):
    """
    Override Window events to close
    """

    def closeEvent(self, event):  # pylint: disable= invalid-name
        """Close Event override

        Args:
            event (_type_): an event
        """

        # ask to leave?
        result = QtWidgets.QMessageBox.question(
            self,
            "Confirm Exit...",
            "Are you sure you want to exit ?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        )
        event.ignore()

        if result == QtWidgets.QMessageBox.Yes:
            # print('inside class')
            # close dialogs

            try:
                ui.log_dia.d_log_dialog.close()
            except:  # pylint: disable= bare-except
                # log.error(e)
                pass
            # kill threads
            # threads_event_list is list of tuples : (kill_ev, local_st, q_dl_stream, map_list)
            print("On Close -> number of threads: ", len(ui.threads_event_list))
            for threads in ui.threads_event_list:
                try:
                    kill_ev = threads[0]
                    kill_ev.set()
                    q_dl_stream = threads[2]
                    q_dl_stream.join()
                except:  # pylint: disable= bare-except
                    pass

            event.accept()


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    main_window = MyWindow()  # QtWidgets.QMainWindow() #Modified to close windows
    ui = UiMainWindowYt()  # .Ui_MainWindow()

    ui.setupUi(main_window)
    ui.setup_ui2(main_window)

    main_window.show()
    sys.exit(app.exec_())
